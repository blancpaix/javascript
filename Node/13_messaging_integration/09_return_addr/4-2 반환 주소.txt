= 4-2 반환 주소 return address
  상관 식별자는 단방향 채널 위 요청/응답 통신을 만들기 위한 기본 패턴
  메시징 아키텍처에서 둘이상의 채널 또는 대기열이 잇거나 잠재적으로 둘 이상의 요청자 있는 경우 충분하지 않음
  상관 ID 외에도 응답자가 요청의원래 보낸 요청자에게 응답할 수있는 정보, 반환주소 도 알아야지?

- AMQP 에 반환 주소 패턴 구현
  AMQP 기반 아키텍처 영역, 반화눚소는 요청자가 응답의 수신을 기다리는 대기열
  응답은 하나의 요청자만이 수신
  대기열은 비공개, 다른 소비자간에 공유되지 않는것이 중요함
  요청자의 연결 범위를 지정하는 대신 임시 대기열이 필요
  응답자가 응답을 전달하기 위해 반환 대기열과 p2p 점대점 통신을 설정해야 함을 추측 가능하지??

  요청자 [A, B] ==>> 브로커 [요청 대기열] ==>> 응답자   ==>> 요청 A 에 대한 응답들 => 요청자 A
                                                      ==>> 요청 B 에 대한 응답들 => 요청자 B

  각 요청자가 자신의 요청에 대한 응답을 처리하기위한 자체 개인 대기열을 갖는거 같지는 않아보이는데...
  모든 요청은 단일 대기열로 전송, 응답자가 처리함
  응답자는 요청에 지정된 반환 주소 정보를 사용, 올바른 응답 대기열로 처리결과를 라우팅함

  AQMP 위에 요청/응답 패턴 만드려면 응답자가 응답 메시지가 전달되어야 하는 위치를 알수 있도록 메시지 속성에 응답 대기열의 이름을 지정하면 됨

- 요청의 추상화 구현
  RabbitMQ 브로커 사용, AMQP 브로커라면 사용가능한거임

  이거 만든거 확인해보시고... 제대로 들어오는 확인 가능
node replier.js
node requestor.js
node requestor.js
  일련의 작업들이 응답자에게 도착, 처리가 완료 시 요청자에게 응답 보내지는거 확인 할 수 있지

  다른 실험 : 응답자가 처음 시작 되면 영구 대기열 생성, 응답자는 중지 한 후 다시 실행해도 요청이 손실되지 않음
  모든 메시지는 응답자가 다시 시작될때까지 대기열에 저장됨

  여기서는 10 초 후 타임아웃 됨, 제시간 안에 도달하기 위해서 응답자는 제한된 다운 타임만이 허락됨

  AMQP 사용, 이점 : 응답자가 즉시 확장 가능하다는 것
  테스트하기 위해 두개 이상의 응답자 인스턴스 시작, 요청간에 부하가 분산되는것을 볼 수 있지
  요청자가 시작할대마다 동일한 영구 대기열에 자신을 리스터로 추가함
  결과적으로 브로커가 큐의 모든 소비자에 걸쳐 메시지를 로드밸런싱 하기때문에 가능함 => 경쟁 소비자 패턴

Tip!
  zeroMQ 는 REQ/REP 라는 요청/응답 패턴을 구현하기 위해 한쌍의 소켓을 가지고 있지만 동기식 (한번에 하나의 요청/응답)임
  보다 나은 기술을 사용하면 복잡한 요청/응답 패턴 가능함
  자세한 내용은 zeromq-reqrep 에서 공식가이드 보고 하세요
  변환주소가 있는 요청/응답 패턴은 redis streams 에서도 사용 가능, AMQP 로 구현한 시스템과 매우 유사함
  * 이거는 연습문제로 남겨둘게요

  