확장성 = 시스템 배포, 여러 프로세스와 시스템에 분할, 다만 사용하려면 통합이 필요
통합 = 시스템 연결

분산 어플 통합의 두가지 주요 기술
  1. 공유 스토리지를 중앙의 중재자와 정보 관리자로 사용
  2. 메시지를 사용해 시스템 노드들에게 데이터, 이벤트 및 명령을 전파,       이거 실제로 차이를 만들며 재미있고 복잡하게 ㅁ나드는 이유이기도 함

메시지는 소프트웨어 시스템의 모든 계층에서 사용함
분산 아키텍처의 메시징 시스템 : 네트워크를 통한 정보 교환을 용이하게 하는 솔류션, 패턴 및 아키텍처의 특정 부류를 설명하는데 씀

몇가지 특징
  브로커 / 피어 투 피어 구조
  요청/응답 메시지 교환 또는 단방향 통신 유형 사용
  큐를 사용해 메시지를 보다 안정적으로 전달

여기서 알아볼 것
-메시징 시스템의 기본사항
-발행/구독 패턴 publish / subscribe
-작업 배포 패턴 및 파이프라인
-요청/응답 패턴


= 01 메시징 시스템의 기초
  -단방향 or 요청/응답 교환과 같은 통신 방향
  -내용을 결졍하는 메시지의 목적
  -컨텍스트 안 또는 컨텍스트 밖으로 송수신 할 수잇는 메시지 타이밍
  -직접 또는 브로커를 통해 발생할 수 잇는 메시지 전달 유형

-01-01 단방향 대 요청/응답 패턴
  가장 기본적, 통신의 방향이며 메시지의 의미를 결정하기도 함
  가장 간단한 통신 패턴 : 단방향 푸시 패턴
    Ex) WebSocket을 사용해 메시지를 보내는 이메일, 웹서버 또는 일련의 작업자에게 작업을 배포하는 시스템

  한쌍을 이루는 요청/응답 교환 패턴
    Ex) 웹 서비스를 호출하거나 dB 쿼리를 보내는 것
    통신 채널이 비동기적이거나 여러 노드를 포함할 경우 복잡해짐
    각 노드별로 생각하면 단방향 통신임, 전체적으로 보면 양방향이고 ㅎㅎㅎ

-01-02 메시지 유형
  메시지는 본질적으로 서로 다른 포스트웨어 컴폰너트들을 연결하는 수단
  다른 컴포넌트가 보유한 일부의 정보를 얻거나 원격으로 작업을 실행하거나, 일부 피어들에게 이벤트 발생을 알리기 위한것일수도

  세가지 유횽의 메시지 식별 가능
  -명령 메시지
  -이벤트 메시지
  -문서 메시지

  -명령 메시지
    본질적으로 직렬화된 명령 객체, 9장의 행위 디자인 패턴의 명령섹션에서 다룸
    목적 : 수신자에서 작업 또는 작업의 실행을 트리거함 (필수 정보는 당연히 넘어와야 함)  
    일반적으로 작업의 이름과 인자의 목록이 포함됨
    Ex) RPC원격프로시저 시스템, 분산 컴퓨팅 구현, 데이터 요청-RESTful HTTP
  
  -이벤트 메시지
    무엇인가 발생함을 다른 컴포넌트에 알리는데 사용 (이벤트 유형, 컨텍스트, 주제, 관련 행위자 정보 포함)
    Ex) WEbsocket으로 클라이언트에게 알림을 보내 시스템 상태 변경을 알림
    분산 어플에서 매우 중요한 메커니즘
  
  -문서 메시지
    컴포넌트들과 머신 사이에서 데이터 전송을 위한것
    Ex) dB 쿼리 결과 전송에 사용되는 메시지
    명령 메시지와 구분하는 주요 특징 : 수행할 작업을 수신자에게 알려주는 정보가 포함되지 않음
    명령 메시지의 응답은 일반적으로 작업 결과만 포함되기에 문서 메시지임
    문서 메시지와의 차이점 : 발생한 특정 사건과 연관성이 거의 없음


  통신 채널???에 대해서 이제 봅시다
-01-03 비동기 메시징, 큐 및 스트림
  비동기 작업의 특징, 원칙이 메시징과 커뮤니케이션 에도 적용가능
  동기식 통신 : 전화 통화와 비슷, 실시간으로 메시지 교환 필요, 다른 연결이 필요할 경우 기존 연결 해제
  비동기 통신 : SMS 와 비슷, 응답 받을수도 안받을수도, 순서에 상관없이 응답, 더 적은 리소스를 사용해 더 나은 병렬 처리 가능
    메시지를 저장한 다음 가능한 빨리 또는 나중에 전달 가능 => 메시지 수신을 보장해야 할 경우 유용
    메시지 대기열 사용, 대상에 전달되기 이전에 메시지를 저장
  [메시지 생성자] ----> [메시지 큐] -----> [메시지 소비자]

  문제 발생 시 메시지는 큐에 누적되어 소비자 재 연결 시 메시지 발송, 대기열인 메시지큐는 다양하게 위치 가능
  로그? 전용 데이터 구조, 내구성이 있고 메시지 도착시 기록에 액세스하여 읽을 수 있음 => "데이터 스트림"
  !스트림에서 메시지는 검색되거나 처리될 때 제거되지 않음
    도착 할 때 메시지 검색하거나 언제든지 스트림 질의를 통해 메시지검색 가능
  스트림은 메시지에 엑세스 할 때 더 많은 자유를 제공
  큐는 소비자에게 한번에 하나의 메시지만을 노출
  가장 중요! 하나 이상의 소비자가 스트림을 공유할 수 잇음, 서로 달느 접근 방식을 사용해 액세스

  시스템의 노드가 서로 연결되는 방식으로 "직접" 또는 "중개자"를 통해 연결될 수 있음

-01-04 피어 투 피어 / 중개자 기반의 메시징
  중앙 집중식 중개 시스템으로 수신자에게 전달

  p2p : 모든 노드는 수신자에게 메시지를 전달할 책임이 잇음
    노드가 수신자의 주소와 포트를 알아야 하며, 프로토콜과 메시지 형식도 알아야 함
    브로커를 제거, 시스템에서 단일 장애 지점을 제거
    브로커는 확장이 필요, P2p는 단일 노드만 확장하면 됨
    통신 대기시간을 줄일 수 있음
    
    특정 기술, 프로토콜, 아키텍처에 얽매이지 않음 => 유연성과 힘

  브로커 : 위의 복잡성을 제거, 각 노드는 완전히 독립적일수도...
    브로커 주요 역할 : 발신자로부터 메시지 수신자를 분리하는것
    세부 정보를 직접 알지 못해도 지정되지 않은 수의 피어와 통신 가능
    서로 다른 통신 프로토콜 간 연결자 역할 가능
    -RabbitMQ 브로커, AMQP, MQTT, STOMP 지원... 뭐 이건 알아서 하고
    
    영구 대기열, 라우팅, 메시지 변환 및 모니터링 등의 추가적인 기능 제공
    p2p로 구현 가능하지만.. 노오력이 필요



=02 발행 / 구독 패턴
  단방향 메시지 패턴 ( 옵저버 패턴 )
  특정 범주의 메시지 수신에 대한 관찰을 등록하는 일련의 구독자 존재
  게시자는 모든 관련 구독자에게 배포되는 메시지를 생성함
  P2P 방식, 브로커 방식이 존재... 그림은 이전의 방법들과 비슷할뿐
  Pub/Sub 특별하게 만드는것 : 게시자는 메시지 수신자가 누구인지 미리 알지 못한다.
  ! 구독자가 특정 메시지를 수신하기 위해 관찰을 등록해야 함.      그러면 다른 사람이 수신을 등록해서 정보를 가로 챌 가능성이 있다는거지
  게시자가 지정되지 않은 수의 수신자들과 작업  가능
  => 양면이 느슨하게 결합되어 진화하는 분산 시스템의 노드 통합에 이상적임

  브로커가 있으면 가입자와 브로커와만 상호작용, 어떤 노드가 메시지 게시자인지 알지 못함 => 시스템 노드 간의 분리가 더욱 향상
  ! 브로커 (중개자)는 메시지 대기열 시스템을 제공, 노드간 연결 문제가 있어도 안정적인 메시지 전달 보장



=03 작업 배포 패턴
  비용이 많이 드는 작업 => 여러개의 로컬 프로세스에 위임, 단일 머신의 한계를 넘어 확장 불가
  여기서 네트워크에 위치한 원격 작업자를 사용해 분산형 아키텍처에서 유사한 패턴을 어떻게 사용할 수잇는지 알아보겠음
  
  작업 분산하는 메시징 패턴, 작업은 개별 작업 청크 또는 분할 정복 접근 방식을 사용하는 더 큰 작업 분할의 일부일수도.?
  구조 : 생산자 => [ 소비자1, 소비자2, 소비자3 ] 각각 작업 할당

  pub/sub 패턴은 위의 유형에 부적합 (여러 작업자가 작업을 받아들이는것이 아님)
  각 메시지를 다른 소비자Worker에게 전달, 로드 밸런서와 유사한 "메시지 배포 패턴" = "경쟁 소비자" , "팬아웃 배포", "벤틸레이터"

  HTTP 로드밸런서와 비슷한데 소비자가 더 적극적인 역할을 함 (연결은 생산자가 아니라 새 작업을 받기 위해 소비자가 함) => 작업자 수 원활하게 늘릴수 있음

  작업자 사이 요청/응답이 필수적인것은 아님.
  대부분 선호 접근 방식 : 단방향 비동기 통신 => 더 나은 병렬 처리 및 확장 가능

  분배 (팬아웃) -> [1,2]    ===>>>    [1, 2] -> 수집 (팬인)    이런 구조라고 보면 됨

  동기식 요청/응답의 오버헤드 없이 매우 복잡한 처리의 아키텍처 구축 가능
  지연시간 줄고 처리량이 높아짐
  메시지가 작업자 집합(팬아웃)에 분산되며 다른 장치로 전달, 최종적으로 단일노드(싱크)로 수집됨

  p2p 방식과 브로커 기반을 분석하여 아키텍처 컴포넌트에 초점을 맞춰보겠음
  - 병렬 파이프라인을 p2p 컨텍스트에서 구현, zeroMQ
  - 브로커 기반 아키텍처 구현 : rabbitMQ

-세부사항은 폴더 별로 들어가서 보세요



= 04 요청 / 응답 패턴
  단방향 통신 - 병렬성, 효율성 이점
  모든 통합, 통신 문제를 해결하기는 불가
  요청/응답 패턴이 작업에 좋은 도구가 될수있음
  우리가 가진것은 비동기 단방향 채널
   => 단방향 채널에서 요청/응답 방식으로 메시지 교환할 수 있는 "추상화"를 만드는데 필요한 다양한 패턴 접근 방식을 알자...

 -04-1 상관 식별자
  첫번째 요청/응답 패턴 : 상관 식별자
  단방향 채널 위 요청/응답 추상화를 만들기 위한 기본 블록

  각 요청을 식별자로 표시, 수신자에 의해 응답 res 에 첨부됨.
  요청 전송자가 두 메시지를 상호 연결하고 응답을 적절한 처리자에게 반환
  단방향 비동기 채널에서 어느 "방향"으로 이동하든 상관없음

  상관 관계 ID 를 사용해 각 응답이 다른 순서로 전송되고 수신되는 경우에도 각 응답을 적절한 요청과 매칭 시킴

  -상관관계 식별자를 사용하여 요청/응답 의 추상화 구현
    예제를 만들어 봅시다
    점대점이면서 전이동(fully duplex: 메시지가 양방향으로 이동가능)

    Ex) Websocket, 서버와 브라우저간 점대점 연결, 메시지는 모든 방향으로 이동 가능
    child_process.fork() 를 사용해 자식 프로세스가 생성될때 생성되는 통신 채널
    이 채널은 부모를 자식 프로세스와만 연결, 메시지를 몯느 방향으로 이동가능 => 비동기식, 점대점 및 전이중 방식
    !! 가장 기본적인 채널임

    부모 프로세스와 자식 프로세스 사이에 생성된 채널을 감싸기 위한 추상화 만들기
      추상화 : 각 요청을 상관 식별자로 자동 표시, 등답 대기중인 요청 핸들러 목록에서 수신한 응답의 ID 로 매칭시켜 d요청/응답 통신 채널 제공
    
    부모 프로세스는 child.send(message) 로 자식에게 메시지 보냄
    child.on('message', callback) 메시지 받음
    자식 프로세스는 process.send(message)로 부모에게 메시지 보냄
    process.on('message', callback) 으로 메시지 받음
    => 인터페이스 채널이 동일, 양쪽 끝에서 사용가능한 공통의 추상화 만들기 가능

 -요청의 추상화
  새로운 요청 보내는 부분 고려, 추상화 구현, createRequestChannel.js
  



요약!
  이장의 끝 도달
  매우 중요한 메시징 및 통합 패턴, 분산 시스템 설계에서 수행하는 역할을 배움
  세가지 유형의 메시지 교환패턴
  -게시 / 구독 (pub/sub)
  -작업 분산
  -요청 / 응답
  위의 패턴에 능숙해야 함
  P2P 위에 구현하거나 브로커를 사용하여 구현 할 수있어야지?
  각 패턴과 아키텍처 장단점 분석 결과
  브로커 (메시지 큐 / 데이터 스트림) 사용 : 적은 노력으로 안정적이고 확장 가능한 어플 구현 가능
    유지보수 및 확장에 필요한 시스템 하나 이상 확보해야하는 비용 존재
    ZeroMQ 사용하여 아키텍처 모든 측면을 완전히 제어할 수있는 분산 시스템 구축, 고유한 요구사항에 맞게 세부 속성 조정 법을 배움

  궁극적으로 두가지 접근 방식 모두 기본 채팅~ 수백만명의 사용자 가능한 플랫폼에 이르기까지 모든 유형의 분산 시스템 구축에 필요한 도구를 제공

  여기는 막장,
  프로젝트에 적용해보세요
  Node 개발이 작동하는 방식, 장점과 약점이 무엇인지 더 깊이 이해하고 있어야 함
  개발자들 솔루션과 패키지 작업할 수있는 기회를 가진거임
  참여자가 모두 무언가를 돌려주는 역할 => Node.js 가 가진 아름다운 특징
  .. 그때까지 기다리겠소
