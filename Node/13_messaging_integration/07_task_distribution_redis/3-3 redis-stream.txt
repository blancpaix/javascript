-03-3 Redis Streams 를 사용한 작업 배포

= redis 소비자 그룹
  redis 중요한 기능... 소비자 그룹임
  redisStreams 위에 경쟁 소비자 패턴을 구현한 것임
  
  소비자 그룹은 이름으로 식별되는 상태 저장 엔티티,
  이름으로 식별되는 일련의 소비자로 구성
  그룹의 소비자가 스트림을 읽으려고 한다면 "라운드 로빈" 설정으로 레코드를 받게 됨

  각 레코드는 명시적으로 응답확인 되어야 함 아니면 보류 pending 상태 유지
  각 소비자는 다른 소비자의 레코드를 명시적으로 요구하지 않는 한 자신의 보류중인 레코드에만 접근 가능
  소비자가 레코드 처리할 동안 문제 발생시 유용함
  소비자 온라인 전환시 보류중 레코드 목록 검색, 스트림에서 새 레코드 요청 전 처리

  생성자 => 스트림 [abcde..] => 소비자 그룹 { 스트림 인터페이스에서 읽음  ==>> [ 소비자 1 - 보류중 레코드, 소비자 2 - 보류중 레코드]} 
                                                                    - 마지막 조회 레코드

  소비자 그룹은 마지막으로 검색된 레코드 ID 저장중, 연속 읽기 작업에서 소비자 그룹은 다음에 읽을 레코드가 무엇인지 알 수있지
  처리중이거나 처리할 수없는 레코드인 보류중 레코드 있는지 확인도 가능
  소비자1은 할당된 보류중 레코드를 재시도 알고리듬 구현으로 처리 가능
  
  ! Redis 스트림은 여러 소비자 그룹 가질 수있음 => 동일한 데이터에 여러 유형의 처리를 동시에 적용 가능하다는거임

  다시 도 해시섬 크래커 만들어봆디ㅏ

= Redis sterams 를 통해 해시섬 크래커 구현
  AMQP와 매우 유사, 큐였는데 여기서는 스트림 (두개) 사용
  스트림 1: 처리할 작업 보관 tasks_stream
  스트림 2: 결과 보관 스트림 results_stream
  소비자 그룹으로 작업을 작업자에 배포() 작업자는 소비자임)
  