브로커가 있으면 메시징 시스템 아키텍처를 단순화 할 수 있음
최선의 해결책은 아님
짧은 지연시간이 매우 중요하거나 복잡한 분산 시스템을 확장할 때  단일 장애 지점의 존재가 옵션이 아닌 모든 상황이 포함될것?? 뭔 말이여
브로커 사용에 대한 대안 : P2p 메시징 시스템 구현

=ZeroMQ 소개
  p2p 아키텍처 적합한 솔루션,   pub/sub, 요청/응답, 단방향 푸시 통신구현하도록 설계딘 소켓 있음
  다양한 메시징 패턴을 구축하기 위한 기본도구 제공, 네트워크 라이브러리
  저수준으로 매우 빠름
  워자 메시지, 부하분산, 대기열 등 견고한 메시징 시스템 구성에 용이함
  프로세스 내 체널(inproc://), 프로세스 간 통신 (ipc://), PGM 프로토콜 (pgm://, epgm://) 사용한 멀티 캐스트, TCP는 기본이지 ㅎ

  pub/sub 패턴을 구현하는 도구 있음
  구독 패턴은 예시에서 알수 잇지
  이전 채팅 앱 아키텍처에서 브로커(Redis)제거, pub/sub 소켓을 활용해 다양한 노드가 p2p 통신하도록 만들겨

= 채팅 서버를 위한 p2p 아키텍처 설계
  브로커 제거 => 채팅 서버의 각 인스턴스는 메시지 수신을 위해 다른 인스턴스에 직접 연결해야 함
  위의 목적을 위해 pub/sub 두가지 유형의 소켓 있음      일반적으로 pub 로컬 바인딩, sub 수신

  구독에서는 sub 소켓에 전달되는 메시지를 지정하는 필터가 있는데... 단순 이진버퍼임
  메시지가 pub 소켓을 통해 전송되면 연결된 sub 소켓으로 브로드캐스트됨, 구독필터가 적용된 후 전송됨
  필터는 tcp와 같은 연결된 프로토콜이 사용되는 경우에만 게시자측에 적용됨

  다양한 인스턴스에도 적용 가능
  아키텍처에 필요한 모든 연결을 설정할 수 있으려면..,, 각 노드가 시스템의 다른 노드를 알고있어야 함

=ZeroMQ PUB/SUB 소켓 사용
  만들면서 봅시다 index.js
  좀 이게 바뀐게 있는데 업데이트는 안된 느낌
  8080 포트 수시낻기 http 서버, 게시자 소켓을 5000, 다른 인스턴스 게시자 소켓 수신대기 5001, 5002
  나머지도 비슷한 방법으로 연결

  ! 구독자 소켓이랑 게시자 소켓 연결 안되어도 상관이 없다. 오류를 발생하지 않음 => 복우너력이 뛰어남
  기본적으로 연결 재시도 메커니즘 구현, 중단되거나 재시작시 유용함
  구독이 없는 경우 메시지 삭제하면 계속 작동함