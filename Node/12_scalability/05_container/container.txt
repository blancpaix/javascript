도커는 컨테이너 이미지화하고 인스턴스 실행하는걸로 그침, 도커만으로 가능을 하겟지만 좀 더 편하게 사용하기 위해서
쿠버네티스를 도입한다는거지?
쿠버네티스 단순하게 오케스트레이션? 이런걸로 도커 이미지를 가지고 서버 용량을 늘리고 줄이고 하느거같은데...
이미지를 그대로 들고와서 배포할거를 따로 등록, 그리고 상태 확인
미니큐브 라는 서비스를 활용해서 로컬에서라도 가상 멀티 인스턴스 세팅으로 테스트 해보는것인듯?

Kubernetes... 컨테이너 및 컨테이너 오케트스레이션 플랫폼
로드밸런싱, 탄력적 확장, 고가용성의 확장 문제의 대부분을 기본 컨테이너 플랫폼에 위임
간단하게 node 어플을 만들수 잇도록 돕는지 보여줄거임

이거는 책의 범위를 벗어나 광범위한 주제라 간단하게 하고 넘길거임

최신 패턴을 탐색하도록 장려...

컨테이너?
  OCI (Opcnen container Initiative) 에 의해 표준화된 컨테이너.
  Linux container는 코드와 모든 종속성을 패키지화하여 처플이 하나의컴퓨팅 환경이 아닌 다른 컴퓨팅 환경에서도 빠르고 안정적으로 실행되도록 하는 소프트웨어 표준 단위

  로컬개발에서 프로덕션 서버에 이르기 까지 어플을 패키징할 수 잇음
  이식성이 매우 뛰어남
  오버헤드가 매우 적다는 장점? => 컨테이너 운영체제에서직접 네이티브 어플을 실행하는것만큼 빠르게 실행되기 때문에
  컨테이너 = 리눅스 운영체제에서 직접 격리된 프로세스를 정의하고 실행 할 수있는 표준 소프트웨어 단위

  가상머신.... => Docker 가 인기가 있음
  https://docs.docker.com/
  여기서 따라 설치하면 됨

컨테이너로 실행하는 방법
package.json 파일 생성... 뭐 책ㄸ라ㅏ 하시고

Docker 에 담으려면 두단계의 프로세스 따라야 함
1. 컨테이너 이미지 빌드
2. 이미지에서 컨테이터 인스턴스 실행

어플의 컨테이너 이미지 생성하려면 Dockerfile 을 정의해야 함
Image : 실제 패키지, OCI 표준을 따름
모든 소스코드와 필요한 종속성이 포함되어잇음. 실행하는 방법을 정의해놔야 함
Dockerfile 은 어플 컨테이너 이미지를 만드는데 사용되는 빈드 스크립트를 정의하는 파일...

// 사용할 기본 임지ㅣ
FROM node:14-alpine
// TCP 수신 포트 지정
EXPOSE 8080
// app.js 와 package.json 파일을 컨테이너 파일 시스템의 /app/ 폴더에 복사함  !! 컨테이너는 격리되어 잇어 기본적으로 호스트 운영체제와 파일을 공유할 수 없음
// 프로젝트 파일에 앳세스 하고 실행할 수 있또록 컨테이너에 프로젝트 파일을 복사해야 함
COPY app.js package.json /app/
// 작업 디렉터리 app 으로 설정
WORKDIR /app
// 컨테이너 실행할 때 어플에서 시작을 위해 실행할 명령을 지정
CMD ["npm", "start"]


docker build -t <TAG> <PATH>
이미지 생성함. 현재 작업 디렉ㅌ처리에서 Dockerfile 을 찾고 실행하여 이미지를 만듦

태그 이름은 [IMAGE_NAME]:[VERSION] 형식을 따르는게 좋음



PS C:\Users\Smart\JS\Node\12_scalability\05_container> docker build C:\Users\Smart\JS\Node\12_scalability\05_container
[+] Building 15.6s (8/8) FINISHED
 => [internal] load build definition from Dockerfile                                                                                                                                                                        0.1s 
 => => transferring dockerfile: 137B                                                                                                                                                                                        0.0s 
 => [internal] load .dockerignore                                                                                                                                                                                           0.1s 
 => => transferring context: 2B                                                                                                                                                                                             0.0s 
 => [internal] load metadata for docker.io/library/node:14-alpine                                                                                                                                                           6.5s 
 => [internal] load build context                                                                                                                                                                                           0.1s 
 => => transferring context: 573B                                                                                                                                                                                           0.0s 
 => [1/3] FROM docker.io/library/node:14-alpine@sha256:9a2aa545388a135b496bd55cef2be920b96c4526c99c140170e05a8de3fce653                                                                                                     7.7s 
 => => resolve docker.io/library/node:14-alpine@sha256:9a2aa545388a135b496bd55cef2be920b96c4526c99c140170e05a8de3fce653                                                                                                     0.0s 
 => => sha256:9a2aa545388a135b496bd55cef2be920b96c4526c99c140170e05a8de3fce653 1.43kB / 1.43kB                                                                                                                              0.0s 
 => => sha256:43ec2ba01c2a245e341489956258afd3535a9ebfdf87ade04b84299ca736607f 1.16kB / 1.16kB                                                                                                                              0.0s 
 => => sha256:f0b94cdce0f39cf2853c3ebedbd1696e64f31f6854918e4672ef5f92099dc9e1 2.36MB / 2.36MB                                                                                                                              0.5s 
 => => sha256:39aa0d19fbe176d43dbe68edc8bb108983b40c55ef6b9f759360b3f5bacf418f 37.13MB / 37.13MB                                                                                                                            4.1s 
 => => sha256:664688b94c1580623bcd4a54c20448eaf12b1da320e8f714fda094ed2faacd85 451B / 451B                                                                                                                                  0.5s 
 => => extracting sha256:39aa0d19fbe176d43dbe68edc8bb108983b40c55ef6b9f759360b3f5bacf418f                                                                                                                                   2.8s 
 => => extracting sha256:f0b94cdce0f39cf2853c3ebedbd1696e64f31f6854918e4672ef5f92099dc9e1                                                                                                                                   0.2s 
 => => extracting sha256:664688b94c1580623bcd4a54c20448eaf12b1da320e8f714fda094ed2faacd85                                                                                                                                   0.0s 
 => [2/3] COPY app.js package.json /app/                                                                                                                                                                                    0.8s 
 => [3/3] WORKDIR /app                                                                                                                                                                                                      0.1s 
 => exporting to image                                                                                                                                                                                                      0.2s 
 => => exporting layers                                                                               
 => => writing image sha256:50c44d557a273012f74df4f3d0d20a3012bba42409a76d22ea1d7c44fd3599bf  

  => => writing image sha256:fc94bb94f1b28079ea89b2d033b25561f86f92c48463599ac4d366f53b68b301      
  // ㄹㄹㄹㄹ      

 이거는 내가 저장을 하고 있어야 하는건가?? 불편한데

도커 이미지 실행
docker run -it -p 8080:8080 <HASH>
태그 지정시 
docker build -t hello-web:v1    -t : 태그 지정
dockr run -it -p 8080:8080 hello-web:v1 
컨테이너 포트 8080이 호스트머신(운영체제)의 포트 8080에 매핑됨      시벌 정확하게 좀 해주지.. 여기는 같은 시스템이라서 상관이 없는데
앞이 도커겟지 아마도???


도커 실행하면 wsl도 같이 실행이 되네??? 자동적으로 할당해서 그런가...


!! 로컬 개발에서 minikube 사용할거니 실행하고 작업하세요.
minikube start
Kubernetes? 이거 쓸거임 이제
  여러 독립 서비스로 구성된 어플, 여러 클라우드 서버에 배포하고 조정해야 함
  Docker 만으로는 충분하지 않음. 클라우드 클러스터에서 사용가능 머신을 통해 실행중인 모든 컨테이너 인스턴스를 조율하는 좀 더 복잡한 방법임
  
  컨테이너 오케스트레이션 도구의 책임
    1. 여러 클라우드 서버를 하나의 논리적 클러스터로 결합, 동적으로 노드 추가 및 제거
    2. 다운타임 유무 체크, 응답 없을경우 인스턴스 재시작, 클러스터 노드가 실패시 다른 노드로 워크로드가 마이그레이션됨
    3. 서비스 검색 및 로드 밸런싱 구현하는 기능을 제공
    4. 내구성잇는 스토리지에 대한 오케스트레이션된 접근을 제공
    5. 다운타임 없는 어플의 자동 롤아웃, 롤백을 제공       롤라웃 & 롤백 : 무중단 서비스를 위해 장애 최소화를 위한 요구사항....
    6. 민감한 데이터 및 설정관리 시스템을 위한 보안 저장 공간 제공 (env 같은거..)

  대규모 클라우드...
  최종상태를 정의하고 오케스트레이터가 클라우드로 구성된 서비스의 안정성을 방해하지 않고 최종상태에 도달하기위해 필요한 과정을 파악할수있도록 선언적으로 구성한 시스템
  전체 개념 : "객체" ==  의도기록?? 객체의 상태를 지속적으로 모니터링 하여 정의된 기대치를 주눗ㅎ나ㅡㄴ지 확인
  객체는 클라우드 배포의 요소로 추가, 제거, 구성 변경이 가능함
  객체의 예시
    - 컨테이너화된 어플
    - 컨테이너 리소스 (CPU, 메모리 할당, 영구 저장소, GPU... 의 접근)
    - 어플 동작에 대한 정책 재시작 정책, 업그레이드, 내결함성

커맨드라인 도구 : kubectl
  개발, 테스트, 프로덕션 목적으로 Kubernetes 클러스터 ㅁ나드는 방법은 여러가지...
  https://kubernetes.io/docs/tasks/tools/
  미니큐브?? 이걸로 쉽게 로컬 단일 노드 클러스터 사용 가능, kubectl, minikube 설치하세요!
  
= Kubernetes 에서 어플 배포 및 확장
  minikube 클러스터에서 간단한 웹 어플 실행할거임
  가장 먼저, docker 이미지 빌드하고 태그 이름 지정
  docker build -t hello-web:v1
  docker build -t hello-web:v1 C:\Users\Smart\JS\Node\12_scalability\05_container 
  
  =Kubernetes 배포 만들기
  !이거 기본적으로 도커에서 쿠버네티스 허용시켜야 함
    minikube 클러스터에서 이 컨테이너의 인스턴스 실행하려면 다음 명령어를 사용해 배포본(쿠버네티스 객체)을 만들어야 함
    kubectl create deplyment hello-web --image=hello-web:v1
      // 쿠버네티스에 hello-web:v1 컨테이너의 인스턴스르 hello-web 이라는 어플으로 실행하도록 지시
    kubectl get deployments
      // 리스트 확인, pod는 동일한 쿠버네티스의 기본단위, 노드에서 함께 실행해야 하는 컨테이너 집합을 말함
      동일한 pod 컨테이너에는 스토리지 및 네트워크 같은 공유 리소스가 있음
      일반적으로1sdds pod 에는 하나의 컨테이너가 있지만 긴말하게 결합된 어플은 pod 에 둘 이상의 컨테이너 표시가 드문것은 아님
    kubectl get pods
    
    = 로컬머신에서 웹 서비스 접근을 위해 배포를 expose 함
    kubectl expose deployment hello-web --type=LoadBalancer --port=8080 
      // 쿠버네티스에 모든 컨테이너의 포트 8080 에 연결, hello-web 앱의 인스턴스를 expose 하는 LoadBanalcer 객체를 생성하도록 지시
    minikube service hello-web
      // minikube start 필요... 이걸로 시작을 한 다음에 이걸 해야함
      // 로컬 주소를 가져와 로드밸런서에 접근할 수있도록 하는... 두오미 명령 이걸로 브라우저 창을 열고 응답을 볼수있찌
      
= Kubernetes 배포 확장
  실제 쿠버네티스 일부 기능 시험
  하나가 아닌 5개의 인스턴스를 실행, 어플을 확장하는것
  kubectl scale --replicas=5 deployment hello-web

  kubectl get deployments
  kubectl get pods
    로 이미지 올라간것 확인
  
= Kubernetes 롤아웃
  새로운 버전의 앱 출시
  docker build -t hello-web:v2
  로 새로운 이미지 빌드
  실행중인 모든 pod를 새로운 버전으로 업그레이드 하기 위해 다음 명령 실행
  kubectl set image deployment/hello-web hello-web=hello-web:v2 -record
  


= 시스템 정리학
  컨테이너 시스템정리, minikube 중지
  kubectl scale --replicas=0 deployment hello-web
  kubectl delete -n default service hello-web
  minikube stop

  docker ps
  docker stop <NAMES>
  // 실행중인 도커 컨테이너 조회 및 중지





12-3  복잡한 어플 분해
  여기서 스케일 큐브 X축에 대한 분석을 집중함
  부하를 분산하고 어플을 확장, 가용성을 향상시키는 가장 쉽고 즉각적인 방법
  
  이번에는 서비스별로 분해, 크기를 조정하는 스케일 큐브의 Y 축에 중점을 둬 볼거임
  어플 용량 줄이고 중요한 복잡성도 확장할 수 있음

12-3-1 모놀리식 아키텍처
  모놀리식 : 모든 서비스가 상호 연결되어 서로 구분이 힘든.. 모듈성이 없는 시스템
  고도로 모듈화된 아키텍처와 내부 컴포넌트 간에 좋은 수준의 디커플링을 가짐.. 드물게
  Ex) 모놀리식 커널 : 리눅스 OS 커널
    Linux 시스템 실행중에도 동적으로 로드 및 언로드 가능한 서비스와 모듈 존재
    모두 커널모드에서 실행됨
    운영체제의 핵심 서비스만 커널모드에서 실행, 나머지는 일반적으로 각각의 고유한 프로세스가 있는 사용자모드에서 실행
      => 마이크로 커널 아키텍처와는 반대
    전체 시스템의 안정성에 영향을 주지 않고 격리된 상태에서 충돌이 발생할 가능성이 높음

  현대 모놀리식 어플은 모놀리식 커널과 비슷함
  컴포넌트 중 하나만 실패하더라도 전체 시스템이 영향받음

  Ex) 전자상거래 어플
  [스토어 프론트엔드, 관리자 프론트엔드, Products, Cart, Checkout, Search, Authentication and Users]    =>    [ 데이터 저장소 ]
  하나는 메인스토어 용, 다른 하나는 관리 인터페이스 용
  모든 모듈이 동일한 코드베이스의 일부, 단일 어플의 일부로 실행되기때문에 따지고보면 모놀리식
  - 문제 1. 컴포넌트 중 하나 오류 발생시 전체 온라인 상점이 다운됨
  - 문제 2. 모듈간의 상호 연결성
  모듈이 동일한 어플 내 존재 => 모듈간 상호작용과 연결을 구축하는것을 매우 간단하게 만듦 (참조를 획득해 직접 사용)
  낮은 결합 유지가 어려움

  높은 결합은 어플 성장의 주요 장애물, 복잡성 측면에서 확장성을 방해

12-3-2 마이크로서비스 아키텍처
  노드에서 가장 중요한 패턴
  ! 커다란 어플을 만ㄷ르지 마십시오
  복잡성과 용량을 모두 확장하는 효과적인 전략임
  스케일큐브의 Y 축, 서비스 및 기능에 따른 분해 및 분할
  필수 컴포넌트로 분해, 별도의 독립적 어플을 만드는것
  모놀리식과 반대
  서비스가 합리적 한도내에서 가능한 작아야 함
  느슨한 결합, 높은 응집력, 높은 통합 복잡성... 등의 집합
  - 전자 상거래 예를 계속해 봅시다
  
  각 컴포넌트 별로 쪼갬
  컴포넌트는 자체 DB와 함께 자체 컨텍스트가 존재하는 자립적으로 독립적인 엔티티
  일련의 서비스를 노출하는 독립적인 어플임

  데이터 소유권!  중요한 특성
  적절한 격리 및 독립 수준 유지, 데이터베이스도 분할해야 함
  고유한 공유 DB 를 사용하면 훨신 쉬운데.... 서비스 간의 결합을 유도하는거임

  모든 노드를 연결하는 선은 어떤 식으로든 정보를 교환하고 통신해야 함
  시스템의 일관성 유지를 위해 더 많은 통신이 필요함

= MSA 장단점
  1. 모든 서비스는 소모품이다
    장점 - 충돌이 전체 시스템에 전파되지 않음
    진정한 독립적인 서비스를 만드는것이 목표
    언어 선택의 용이함
  2. 플랫폼 및 언어 간의 재사용성
    작은 서비스 분할 시 쉽게 재사용 가능한 독립적 단위를 만들 수 있음
      -Ex) Elasticsearch (검색서비스), ORY (인증 및 구너한 부여)
    정보 숨김 수준이 모놀리식보다 높음 = 상호작용이 원격 인터페이스로 주고 받음 => 구현의 세부정보 숨김, 인프라 언어 등.... DB 보호
= 어플 확장 방법
  Y 축 확장, 다른 MSA 를 2차원 결합하여 더 확장 가능

= MSA 과제
  노드가 많아 통합, 배포, 코드 공유 측에서 복잡성 증가
  배포 확장 모니터링 시 온전성 유지??? 서비스 간 코드 공유하고 재사용??
  Devops 방법론이 해답이 될 수 있지
  모듈시스템이 완벽함


12-3-3 MSA 아키텍처 통합 패턴
  가장 어려운 문제 : 모든 노드를 연결하여 공동작업을 수행해야 함
  서비스간의 상호작용 필요, 상태가 최신 정보의 상태로 유지되어야 함

= API 프록시
  클라이언트와 일련의 원격 aPI 간의 통신을 프록시하는 서버인 API 프록시 를 사용하는것
  여러 API 엔드포인트에 단일 액세스 포인트 제공 + 로드밸런싱 + 캐싱 + 인증 및 트래픽 제한 제공
  본질적으로 역방향 프록시랑 마찬가지임
  사진을 보시고...
  노드 (서버) 가 많을 수있는 인프라에서 매우 편리함
  복잡한 구조에 단일 뷰를 제공해 편리함
  모든 aPI 에 대한 연결의 복잡성을 추상화, 다양한 서비스를 자유롭게 재구성 가능

  단일 엔드포인트  - 서비스 별 서버 분리

= API 오케스트레이션
  서비스 집합을 통합하고 구성하는 가장 자연스럽고 명시적 방법
  모델링된 데이터 요소 및 기능을 취하여 대상 개발자 또는 어플을 위한 보다 구체적인 수단을 제공하는 추상화 계층임

  "일반적으로 모델링 된 요소 및 기능" = MSA의 서비스 설명과 완벽하게 일치함

  프론트엔드 [
    Store frontend [],
    API 오케스트레이션 계층[
      completeCheckout(),     =>>> 세분화
      cancelCheckout(),
      addToCart(),
      ...
    ]
  ]
  
  세분화 1. checkoutService/pay -----> 결제 서비스 [Checkout]
  세분화 2. cartService/delete  -----> 카트 서비스 [Cart]
  세분화 3. productsService/update --> 제품 서비스 [Products]

  위의 방법은 더 복잡하고 구체적인 기능을 만드는 방법을 보여줌
  시나리오 = 고객이 결제가 긑날때 지불 버튼을 클릭하는 순간 호출되는 가상의 completeCheckout() 서비스
    세단계의 복합 연산 구성
    1. checkoutService / pay 를 호출해 거래를 완료
    2. 결제 완료 시 Cart 서비스에 상품을 구매했으니 장바구니에서 제거 가능함을 알림. cartService/delete 호출하여 수행
    3. 결제 완료 시 구매한 상품의 재고 여부 업데이트, productsService/update 수행

  세가지 다른 서비스, 세가지 연산을 가지고 전체 시스템 일관된 상태로 유지해야 함....

  API 오케스트레이션 계층에서 일반적인 작업 = 데이터 집계 = 서로 다른 서비스의 데이터를 단일 응답으로 결합
  Ex) cart 포함된 모든 제품 나열 => CArt 서비스에서 제품 id 목록을 검색, 제품 서비스에서 제품에 대한 전체 정보를 검색해야 함
    중요한 패턴은.. 여러 서비스와 특정 어플간의 추상화 역할을 하는 오케스트레이션 계층의 역할임
  
  오케스트레이션 계층은 추가직언 기능 분할을 위한 좋은 후보, API 오케스트레이터로 전용 독립 서비스 구현이 매우 일반적임
  API 프록시랑 유사하지만, 오케스트레이터는 다양한 서비스의 의미 통합을 수행, 서비스에 의해 노출된것과 다른 API 를 노출하기도 함 (프론트엔드랑 분리?)


  ** 오케스트레이터 패턴 : 다양한 서비스를 명시적으로 통합하는 메커니즘 제공
  설계, 디버그, 확장 쉬움
  기본 아키텍처와 각 서비스의 작동방식에 대한 완전한 지식이 있어야 함
  God 객체(안태패턴)가 될수도... 높은 결합, 낮은 응집력, 높은 복잡성을 야기함... 그래서 비추인듯?

= 메시지 브로커와의 통합
  서비스 전반에 걸쳐 전체 시스템의 정보를 동기화하는 책임을 분산시키기 위함
  최종적으로 서비스간의 직접적인 관계를 만드는것
  노드간의 상호 연결수 증가 => 높은 결합, 복잡성은 더욱 증가,,,.... 따라서 서비스간의 직접적인 관계를 만들되,구성된 모든 서비스를 분리된 상태로 유지해야 함
  모든 서비스는 특정 서비스가 없어도 잘 작동해야 함

  해결책 : 메시지 수신자로부터 발신자를 분리, 메시지 브로커 사용 pub/sub 패턴 사구현
  그림 12.14 참조하셈
  프론트엔드에서 호춣로 서버 실행, 그 정보는 메시지 브로커로 전달된 후 모든 서비스에 전파되는듯?
  모든 통합 작업은 프론트가 아닌 백그라운드에서 이뤄짐

  영구 메시지 대기열 / 메시지 순서 보장 과같은 기능이 필요할수도...




