어플리케이션 확장
고가용성과 내성
어플리케이션 복잡성을 관리하기 쉽게 분할하는 방법....

어플의 지속적인 수요 증가 감당하는 방법?

ndoe 단일 스레드 컨텍스트에서 실행된다!, 장점이긴 한데
블로킹 io 패러다임 덕분에 동시 요청을 처리한느데 필요한 리소스 사요을 최적화 할 수 잇음


12-1-2 3차원 확장성
  x축 - 복재 : 모놀리식, 단일 인스턴스 => n개의 인스턴스
  y축 - 서비스/기능별 분해,      각 고유한 기반을 사요한느 독립형 어플을 만듦
  z축 - 데이터 파티션으로 분할,   각 인스턴스가 전체 데이터의 일부만 담당, DB에서 자주 사용하는 방식 (샤딩??)

12-2 복제 및 로드밸런싱
  수평적으로 확장 (인스턴스 개수 증가), // 수직 : 성능 증대
  단일 스레드인 노드는 기존 우베 서버에 비해 훨씬 더 빨리 확장되어야 함
  초기 단계부터 확장성을 고려하도록 하여 어플이 여러 프로세스 또는 시스템에서 공유할 수 없는 리소스에 의존하지 않도록 해야 함
  절대 조건 : 각 인스턴스가 메모리나 디스크와 같이 공유할 수 없는 리소스에 공통정보를 저장할 필요는 없다!
  ex) 웹 서버에서 세션 데이터를 메모리나 디스크에 저장하는것은 적합하지 않다! 대신 공유 DB를 사용하도록...

12-2-1 클러스터 모듈
  어플 부하 분산 가장 간단한 패턴 : cluster 모듈 사용, 연결을 자동으로 배분함
  마스터 프로세스 - 작업자 1         마스터 프로세스 :  여러 프로세스 (짝업자)를 생성하는 역할, cpu 수만큼 작업자 생성 가능
                 - 작업자 2
                 - 작업자 3    이런식으로
  클러스터 모듈은 명시적으로 라운드 로빈 로드 밸런싱 알고리듬을 사용함 => 균등한 분배가 됨
  server.listen() 에 대한 모든 호출은 마스터 프로세스에 위임됨
  이를 통해 마스터 프로세스는 들어오는 모든메시지를 수신하고 이를 작업자 풀에 배포 가능
  작업자 모듈에서 server.listen() 을 호출함녀 다음과 같이 예상한 대로 동작 안할 수 있는 주의 사항 필요
  -server.listen({ id }) 작업자가 특정 파일 설명자를 사용해 수신하는 경우 프로세스 수준에서 맵핑 되어 교환되는 파일이 일치하지 않으루 소디 잇음
    마스터 프로세서에서 파일 설명자를 만든 후 작업자 프로세스에 전달하는것 => 으로 해결 가능...
  -server.listen(handle) : 제공된 핸들을 직접 사용하게 됨
  -server.listen(0) : 일반적인 서버가 임의의 포트에서 수신함 (무작위)
  

클러스터 모듈의 탄력성 및 가용성
  작업자는 모두 별도의 프로세스
  node 는 작업자수를 자동으로 관리하지 않음
  오류 발생해도 서비스 유지 : 복원력, 시스템 가용성
  여러 인스턴스에서 동일한 앱 실행, 중복된 시스템 생성
  다른 인스턴스가 요청 처리할 준비 됨 => 클러스터 모듈을 사용해 구현하는것이 편함
  
  